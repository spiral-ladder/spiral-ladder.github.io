 
<!DOCTYPE html>
<html lang='en-US'>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Grug Brained Guide to KZG Polynomial Commitments</title>
  <meta name="description" content="">
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="canonical" href="https://spiral-ladder.github.io/tech/2024/01/07/grug-brained-guide-to-kzg-polynomial-commitments-dj.html">
  <link rel="alternate" type="application/rss+xml" title="bh" href="https://spiral-ladder.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'Open Sans'; src: url('/css/OpenSans-300-Normal.woff2') format('woff2');
    font-weight: 300; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Italic.woff2') format('woff2');
    font-weight: 400; font-style: italic;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Italic.woff2') format('woff2');
    font-weight: 700; font-style: italic;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  body {
    max-width: 80ch;
    padding: 2ch;
    margin-left: auto;
    margin-right: auto;
  }

  header { margin-bottom: 2rem; }
  header > nav { display: flex; column-gap: 2ch; align-items: baseline; flex-wrap: wrap; }
  header a { font-style: normal; color: rgba(0, 0, 0, .7); text-decoration: none; }
  header a:hover { font-style: normal; color: rgba(0, 0, 0, 1); text-decoration: none; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { margin-top: 2rem; }
  footer > p { display: flex; column-gap: 2ch; justify-content: center; flex-wrap: wrap; }
  footer a { color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  </style>

  <link rel="stylesheet" href="/css/site.css">
  
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">bing</a>
      <a href="/about.html">About</a>
      <a href="/favourites.html">Favourites</a>
    </nav>
  </header>

  <main>
  <article >
<section id="Grug-Brained-Guide-to-KZG-Polynomial-Commitments">

<div class="title"><h1>Grug Brained Guide to KZG Polynomial Commitments </h1><time class="meta" datetime="2024-01-07">Jan 7, 2024</time></div>
<p>In this post, I'm aiming to explain to myself what a KZG polynomial
commitment is, and talk about my <a href="https://github.com/bingcicle/kzigg">Zig
implementation</a>. If you're only
curious about the Zig usage, feel free to skip to the last section.</p>
<section id="why-another-explainer">

<div class="title"><h2>Why another explainer? </h2></div>
<p>Most blog posts/explainers I found out there start off with the heavy
math or the deep technical components of what a KZG polynomial
commitment is right away. They also are often disconnected, going from
one concept to the next without making it very clear how it all links
together. The real kicker imo is that none really starts off with the
motivation behind KZG in the context of Ethereum and a brief technical
overview first. The closest I found was
<a href="https://twitter.com/protolambda">@protolambda</a>'s <a href="https://hackmd.io/@protolambda/eip-4844-implementer-notes">implementor
notes</a>.</p>
<p>So this post is more of a post to myself prior to learning about KZG,
and is meant to be a bridge to the more
<a href="https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html">technical</a>
<a href="https://alinush.github.io/2020/05/06/kzg-polynomial-commitments.html">and</a>
<a href="https://www.zkdocs.com/docs/zkdocs/commitments/kzg_polynomial_commitment/">instructional</a>
<a href="https://scroll.io/blog/kzg">articles</a> (each word here is a link!) that
already exists out there.</p>
<p>This post might be helpful if you think like me and require some
motivating examples and a high level overview first to put the technical
knowledge into practice. Otherwise, more technical readers should
probably read the above links instead.</p>
</section>
<section id="why-kzg-commitments">

<div class="title"><h2>Why KZG commitments? </h2></div>
<p>Before we understand what a KZG commitment is, I'd like to think that
we should understand what they're used for first.</p>
<p>For a long while, Ethereum transaction fees have been way too expensive
for regular users. Every transaction you made had to be processed by
every participating validator in the network, and the fees that you pay
is the cost of processing those transactions.</p>
<p>Rollups were meant to solve this problem by bundling transactions
together but even rollup fees can get too expensive for many users since
rollups still need to pay for the data posted onto mainnet, and this
posting of data is a function of how large the data blobs are and the
current L1 gas price.</p>
<p>Knowing the above, the solution is probably to</p>
<ol>
<li>
either post less data or not post the data at all, and/or
</li>
<li>
have some sort of gas-agnostic way to post the data
</li>
</ol>
<p>The long term solution is to shard data which takes time to implement,
so a stopgap solution is necessary to make fees cheaper for now. This
stopgap is <a href="https://eips.ethereum.org/EIPS/eip-4844">EIP-4844</a>. The crux
of it is to introduce the <em>transaction format</em> that will be used in
sharding but not actually shard those transactions. This (kinda)
addresses the 2 problems above. Notably, point 1 is where <strong>KZG
commitments</strong> come in.</p>
<p><strong>"<em>either post less data or not post the data at all</em>"</strong></p>
<p>Currently, transaction data is stored within the calldata, which is
visible to the EVM and is a permanent part of the blockchain. EIP-4844
introduces blob-carrying transactions which makes Ethereum store data on
the consensus layer rather than the execution layer (EVM). Rather, what
the execution layer sees is the <em>commitment</em> to those blobs. These
commitments are smaller in size which saves on gas, and it is sufficient
to verify these commitments without needing to access the actual blobs.</p>
<p>Note here also that the consensus layer also does not store the blobs in
perpetuity - the role of the consensus layer is to provide a <strong>secure</strong>
real-time view of what is being published.</p>
<p><strong>"<em>have some sort of gas-agnostic way to post the data</em>"</strong></p>
<p>So 4844 solves this by introducing an entirely separate fee market for
blobs (which is why I said <em>kinda</em> above). This is out of scope of this
post, since it has nothing to do with how KZG works. Instead, the
<a href="https://notes.ethereum.org/@vbuterin/proto_danksharding_faq#What-does-the-proto-danksharding-multidimensional-fee-market-look-like">proto-danksharding
FAQ</a>
has a section that goes in-depth into the fee market structure.</p>
</section>
<section id="kzg-commitments">

<div class="title"><h2>KZG commitments </h2></div>
<p>Now we can get to how we achieve point 1 mentioned above. Commitment
schemes allow one to publish a value which binds one to a message
without revealing it. One can then open the commitment and reveal the
committed message to a verifier to be checked. Of course this only makes
sense if the cost of committing is less than the cost of sending the
entire message.</p>
<p><a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">KZG (Kate-Zaverucha-Goldberg)
commitments</a>
are a class of the above scheme.</p>
<p>Some key characteristics that is useful for 4844:</p>
<ul>
<li>
Constant size commitment/proof (48 bytes). This is especially useful
for batching, since the proof size is always constant regardless of
the size of the blob.
</li>
<li>
Verification is a single pairing check (constant time)
</li>
</ul>
</section>
<section id="how-it-works-eli5">

<div class="title"><h2>How it works, ELI5 </h2></div>
<p>The scheme itself is stupidly simple from an engineering POV and I
didn't realize this myself prior to implementing it (The math is super
complicated though). @protolambda explained it best in the notes linked
at the top: you only need</p>
<ol>
<li>
a linear combination to compute a KZG commitment,
</li>
<li>
a single pairing verification to verify a KZG proof
</li>
</ol>
<p>Obviously there are way more details behind how the above steps happen
(serialization/deserialization of blobs, how pairings work,
optimizations, etc.), but the above 2 steps is really all that is
happening in the scheme.</p>
<p>Again, I would highly recommend the other articles for the math but
nevertheless I will give a short overview here - note that this is in
the context of blobs. I will also (try to) include the little details I
noticed in the code that some articles I've read seem to have missed
out on.</p>
</section>
<section id="setup">

<div class="title"><h2>Setup </h2></div>
<p>Some commitment schemes use some secret value within its computation,
and this secret value is often obtained via something called a <a href="https://ceremony.ethereum.org"><strong>trusted
setup</strong></a>.</p>
<p>Essentially this is a multiparty procedure where each party creates some
secret and runs a computation to mix it with the previous contributions.
Eventually, the final secret value will be used for the commitment
scheme. This secret value will be used to compute <strong>all</strong> group elements
that are available to the prover and the verifier.</p>
<p>The cool thing about this trusted setup is that it has a "1-of-N"
trust assumption, which means only a single participant is required to
be honest for the procedure to be secure. That means, unless you don't
trust yourself, trusted setups are generally OK to trust.</p>
<p>Some fun numbers: there were <strong>141,416</strong> contributors to the <a href="https://ceremony.ethereum.org/">KZG
ceremony</a>, and the ongoing (as of
writing this) <a href="https://summoning.penumbra.zone/">Penumbra summoning
ceremony</a> already has about <strong>11,799</strong>
contributors!</p>
</section>
<section id="commit">

<div class="title"><h2>Commit </h2></div>
<p>As mentioned earlier, a commitment is simply a linear combination. A
blob of bytes has its data transformed into a polynomial and then a
linear combination done on its points, producing a serialized G1 point
(48 bytes in size) which serves as the commitment. This is further
compressed into a versioned hash (32 bytes) for forward compatibility.</p>
<p>This process can be done naively (very slow) or via Pippenger's
algorithm.</p>
</section>
<section id="prove">

<div class="title"><h2>Prove </h2></div>
<p>Now we want to show that we know the original data in the blob,
otherwise the polynomial. In other words, we want to show that we know
<span class="math inline">\(p(z) = y\)</span>, where y is the evaluation of the polynomial at some point
<span class="math inline">\(z\)</span>.</p>
<p>The simplest way to do that is if the prover sends the entire polynomial
to the verifier, but that would defeat the point of the commitment
scheme - we would ideally want cost savings when we go through the
trouble of using such a scheme!</p>
<p>Now what is this is point <span class="math inline">\(z\)</span>? This is usually called a <strong>challenge</strong> -
this is a random field element that the verifier sends to the prover,
allowing the prover to evaluate the polynomial to prove its integrity.
This requires the prover and verifier to communicate directly with each
other, which isn't ideal. Instead, we rely on the Fiat-Shamir heuristic
by letting the prover and verifier agree on a format prior to the
protocol to simulate this interaction. Both the prover and verifier
independently calculate the challenge, by hashing a 'transcript' (the
simulation) into a field element, which serves as our challenge.</p>
<p>Using this challenge to evaluate the polynomial, we get the <strong>evaluation</strong>
and the <strong>evaluation proof</strong> that attests to the fact that the polynomial
was correctly evaluated in the eyes of the prover.</p>
<p>The evaluation proof is actually the <strong>quotient polynomial</strong> <span class="math inline">\(q(x)\)</span> such
that</p>
<p><span class="math display">\[
q(x) = \frac{p(x) - y}{x - z}
\]</span></p>
<p>To derive this: we know that if <span class="math inline">\(z\)</span> is a root of <span class="math inline">\(p(x)\)</span>, then
<span class="math inline">\(p(z) = 0\)</span>, Using this property, we can actually take advantage of the
fact that <span class="math inline">\(p(x) - y\)</span> is zero at <span class="math inline">\(z\)</span> to express a quotient polynomial
<span class="math inline">\(q(x)\)</span>.</p>
</section>
<section id="verification">

<div class="title"><h2>Verification </h2></div>
<p>Verification is then done with a pairing check, which I treated as a
black box for this post and implementation because I don't know enough
to make sensible comments. Instead, I've linked to Vitalik's <a href="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627">blog
post</a>
on the topic.</p>
</section>
<section id="batching">

<div class="title"><h2>Batching </h2></div>
<p>Interestingly enough, we can re-express the above quotient polynomial in
order to batch prove across a set of points:</p>
<p><span class="math display">\[
q(x) = \frac{p(x) - i(x)}{z(x)}
\]</span></p>
<p>Here, <span class="math inline">\(i(x)\)</span> is a polynomial (in Lagrange form) of a set of points to
prove, and <span class="math inline">\(z(x)\)</span> is the <strong>zero</strong> or <strong>vanishing polynomial</strong> that is the
set of linear factors that can divide <span class="math inline">\(p(x) - i(x)\)</span>.</p>
<p>Verification is then just using the same pairing check, except on linear
combinations of group elements instead! You can see this in action
within the code, where linear combinations (naively computed for
security reasons) are done in the batch verification function, both in
my port as well as the original version.</p>
</section>
<section id="zig-implementation">

<div class="title"><h2>Zig implementation </h2></div>
<p>I ported <a href="https://github.com/ethereum/c-kzg-4844">c-kzg-4844</a> to Zig
just to learn what goes behind the scheme. I wrote previously about
<a href="https://bingcicle.github.io/posts/ziggifying-kilo.html">porting another C
project</a> to Zig
so for general impressions you can check that post out. I'll post
thoughts specifically comparing my implementation with the C version.</p>
</section>
<section id="c-interop">

<div class="title"><h2>C Interop </h2></div>
<p>For the Zig implementation, like the C version, I relied on
<a href="https://github.com/supranational/blst"><code>blst</code></a> for the backend, which
means I had a chance to finally try C interop after using Zig for some
time. Zig natively supports <a href="https://ziglearn.org/chapter-4/">C ABIs</a>,
making it possible for new programs to be built leveraging C libraries.</p>
<p>Frankly, it surprised me with how easy it was to just build <code>blst</code> and
use it as a static library in Zig. Zig pointers also coerce nicely to C
pointers, which was super convenient to not have to do weird casts when
calling <code>blst</code>.</p>
<p>Why bother with C? Well, when a C library is audited and battle-tested,
it may be better to just use it rather than reinvent the wheel, which is
exactly what Zig enables you to do easily.</p>
</section>
<section id="defer-is-great">

<div class="title"><h2>Defer is great </h2></div>
<p>In the C implementation, there's heavy abuse of <code>goto</code>s in order to
free data whenever some computation finishes or when errors occur. This
is where C gets a bad rap, because the need to do manual memory
management along with copious amounts of indirection leads to bug-prone
code.</p>
<p>Instead of doing all that, Zig encourages the <code>alloc-defer</code> pair
pattern:</p>
<pre><code class="language-zig">    const allocator = std.testing.allocator;
    // This allocates
    const cfg = try KZGTrustedSetupConfig.loadFromFile(
        allocator,
        "./src/trusted_setup.txt",
    );
    // This frees when out of scope
    defer cfg.deinit();
</code></pre>
<p>This means less cognitive load on thinking about where and when to free
your memory.</p>
</section>
<section id="general-cleanliness">

<div class="title"><h2>General cleanliness </h2></div>
<p>Generally, the Zig version felt slightly cleaner to me and came out to
about ~1100LOC (including tests). The
<a href="https://github.com/ethereum/c-kzg-4844/blob/main/src/c_kzg_4844.c">c_kzg_4844.c</a>
file alone came to about 1.5x of that.</p>
</section>
<section id="conclusion">

<div class="title"><h2>Conclusion </h2></div>
<p>Implementing the 4844 variant of KZG for myself was a good practice for
me to uncover what goes behind the scenes during KZG, and its connection
to EIP-4844. While this isn't really made to be used as a SNARK, it is
still really cool to see commitment schemes used in practice.</p>
<p>Commitment schemes are like magic when applied in the right scenarios to
save on space and the work to be done.</p>
</section>
</section>
</article>
  </main>

  <footer>
  </footer>
</body>

</html>
